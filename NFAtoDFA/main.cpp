//
//  main.cpp
//  NFAtoDFA
//
//  Created by 양준식 on 2020/06/04.
//  Copyright © 2020 양준식. All rights reserved.
//

#include <iostream>
using namespace std;
#include <cstring>
#include <string>
#include <map>
#include <vector>
#include "nfatable.hpp"

//q0, q1과 같은 dfa의 state들은 nfa의 120개 state들 즉, 0~119번 에서 몇가지를 합쳐서 ㅇ갖고있으므로, 그 {0,14, 25}와 같아지는 dfa의 state를 vector<int>로 나타내었다. 배열로 하기에는 몇개가 될 지 모르기때문. 이 프로그램에서 vector<int>는 dfa의 state라고 보면된다. 그리고 이vector들을 차례로 저장할 vector인 statelist를 생성했다. statelist는 vector<int>를 원소로 갖기때문에 선언을 vector<vector<int>>로 하였다.
 
  

bool vecComp(vector<int> a, vector<int> b){
   
    if(a.size()!=b.size()){
        return false;
    }
    
    else{
        for(int i=0;i<a.size();i++){
          
            if(a[i]==b[i]){
                continue;
            }
            else{
                return false;
                
            }
        } return true;
        
    }
    
    
}

vector<int> eMoveResult(vector<int> a){ //state를 나타내는 벡터에서, 입실론 무브 만으로 갈 수 있는state들 모두 구해서 새로운 벡터를 리턴해주는 함수.
    if(a.empty()==true){
        return a;
    }
    vector<int> tempV1;
    vector<int> tempV;
    vector<int> resultV;
    int tempa;
    int finalle=0;
    tempV=a;//tempV에 a를 그대로 복사.
    tempV1=a;
    
    while(true){
    
    for(int j=0;j<tempV.size();j++){//e-move로 갈 수 있는 state들을 모두 추가하는 과정
        
          tempa=tempV[j];
     for(int k=0;k<120;k++){ // 인풋으로 받은 벡터에 있던 원소라도 일단, 입실로 무브로 갈 수 있는 nfa state(item)이라면 일단 tempV에 추가해놓는다.  겹치는 item들은 나중에 뒤에서 제거해준다.
         
        if(nfa[tempa][k]=="ε"){
           
                tempV1.push_back(k);
            
        }
      }
        
    }
        ///////////////  ///////////////  ///////////////  ///////////////  ///////////////  ///////////////  ///////////////  ///////////////  ///////////////  ///////////////
         // 겹치는 item들 없애주는 과정
         sort(tempV1.begin(),tempV1.end()); // 오름차순으로 정렬!!
        
         resultV.push_back(tempV1[0]);
         
         for(int i=0;i<tempV1.size();i++){
             if(tempV1[i]!=resultV.back()){
                 resultV.push_back(tempV1[i]);
             }
         }
        tempV1=resultV;
     sort(tempV1.begin(),tempV1.end()); // 오름차순으로 정렬!!
    if(vecComp(tempV,tempV1)==false){//두 벡터가 다를 경우
        resultV.clear();
        tempV=tempV1;
        continue;
    }
    else{//두 벡터가 같을 경우
         sort(tempV1.begin(),tempV1.end()); // 오름차순으로 정렬!!
        finalle++;
        if(finalle==10){
            return tempV1;}
    }
        
    }
    
   }




vector<string> possible_tran_sym(vector<int> a){//eMoveResult함수를 거친 정수 벡터에서, 어떤 transition symbol로 유효하게 다른 state로 갈 수 있는지, 그 목록을 만들어주는 함수. {"CODE", "vtype", "id"} 와 같이 리턴해주고, 갈 수 있는 길이 없다면,벡터에 {"NONE"}이렇게 리턴
    
    vector<string> tempSV;
    int temp;
    
    for(int i=0;i<a.size();i++){
         temp=a[i];
   
     for(int j=0;j<120;j++){
         if(nfa[temp][j]!="ε" && nfa[temp][j]!="n"){
             tempSV.push_back(nfa[temp][j]);
         }
       }
        
     }
    /////////////////////위에서 한 과정은 tempSV를 만들어주고 , 인자로 받은 a벡터의 모든 item들에서 뻗어갈 수 있는 transition symbol들 (입실론 제외)을 저장해준 것.
     vector<string> resultSV;
    
    if(tempSV.empty()==true){//갈 수 있는 transition smbol이 없다면 없는대로 리턴.
        
        return resultSV;
    }
    
 
      
     else if(tempSV.size()==1){
        return tempSV;
     }
     
    sort(tempSV.begin(),tempSV.end()); //정렬 이제 아래에서 같은원소 두 번 이상인거 없애줄거임
  
    resultSV.push_back(tempSV[0]);
    
 
        
    for(int k=0;k<tempSV.size();k++){
        if(tempSV[k]!=resultSV.back()){
            resultSV.push_back(tempSV[k]);
        }
    }
    
    sort(resultSV.begin(),resultSV.end()); //정렬 이제 아래에서 같은원소 두 번 이상인거 없애줄거임
    return resultSV;
   
}
/*vector<int> svToiv(vector<string> a){//트랜지션 벡터를 맵과 함께 이용하여 숫자벡터로 바꿔줌
    string temp;
    vector<int> resultV;
    for(int i=0;i<a.size();i++){
        temp=a[i];
        resultV.push_back(tsMap[temp]);
    }
    sort(resultV.begin(),resultV.end());
  return resultv;
}
*/

void showIVec(vector<int> a){ //state가, 즉 vector<int>가 갖고있는 모든 원소들을  출력해서 보여주는 함수
    cout<<"{ ";
    for(int i=0;i<a.size()-1;i++){
        cout<<a[i]<<" , ";
    }
    cout<<a[a.size()-1];
    cout<<" }";
}
void showSVec(vector<string> a){ // vector<string>가 갖고있는 모든 원소들을  출력해서 보여주는 함수
    cout<<"{ ";
    for(int i=0;i<a.size()-1;i++){
        cout<<a[i]<<" , ";
    }
    cout<<a[a.size()-1];
    cout<<" }";
}

//한개의 가능한 input symbol에 대해서 그걸로 시작해서 갈수 있는 state들 목록(벡터) 만들어주고 이 함수 안에서 eMoveResult함수 써서 최종 다음 dfa state를 만들어서 리턴해주자. 매개변수로 해당 출발하는 dfa state 벡터랑, transition symbol 번호를 매개변수로 줘야겠지.
vector<int> dfaNextState_needEMR(vector<int> q, string transym){
    vector<int> symMove;
    int temp;
    //트랜심으로 갈 수 있는 nfa state들 모두 구하고,
    //그거에 eMoveResult 돌려서 다음 dfa state를 구할 수 있는거다.
    //익=렇게 리턴해준 state가 기존 등록된 state와 겹치지 않으면, 등록해주고, ...
    for(int j=0;j<q.size();j++){ //벡터 q의 원소를 하나씩 가져옴
          temp=q[j];
    
      for(int i=0;i<120;i++){
          if(nfa[temp][i]==transym){
             symMove.push_back(i);
          }
        }
         
      } // 포문 두개 돌고 나오는 것은 q의 각 원소들에서 정해진 심볼 transym을 한 번 거쳐서 갈 수 있는 nfa state들이다.이제 이 state들ㅇ에서 eMoveResult 때려서 나온 놈을 다음 dfa state로. 해줄 수 있다(겹치지않는다면)
   
   
    return symMove;
  
}



int main(int argc, const char * argv[]) {
    
    
  string smap[35]= {"vtype","num","float","literal","id","if","else","while", "for", "return", "addsub", "multdiv", "assign", "comp", "semi", "comma", "lparen", "rparen", "lbrace", "rbrace", "CODE", "VDECL", "ASSIGN", "FDECL", "ARG", "MOREARGS", "BLOCK", "STMT", "ELSE", "RHS", "EXPR", "TERM", "FACTOR", "COND", "RETURN"};
    
    int DFA[85][35]={ {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85},
        {85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85}
        
        
     
        
    }; //세로축은 아직 몇개 생길지 모름 nfa로 dfa변환해봐야 총 dfa의 state가 몇개 나올지 알 수 있음.
  //가로축은 DFA에서 가능한 모든 transition symbol들, 즉, non-terminal 과 terminal들로 총 35개.
    vector<vector<int>> statelist;
    
  
    vector<int> ns;
    ns.push_back(0); //dfa의 start state를 만들기 위해 nfa의 0번 state를 먼저 넣어준다.
    vector<int> tempns;
   
    tempns=eMoveResult(ns);
  
    statelist.push_back(tempns);
   

 
     
    int sln=0;//dfa state의 번호라고 보면 됨.
    vector<string> tempSV;
   
    int temint;
    vector<int> temv;
    int existStateNum;
    //while 문 들어갈 때 statelist는 첫 원소에 emoveResult를 거친 첫 dfa state만 들어가있는 상태이다.
    int ssno=0;
    while(true){
        ssno++;
        if(statelist.size()<=sln){
            break;
        }
       
     
        tempSV=possible_tran_sym(statelist[sln]);
        for(int y=0;y<tempSV.size();y++){
            cout<<tempSV[y]<<" ";
        }cout<<endl;
    if(tempSV.empty()==true){ //해당 상태에서 symbol로 갈 수 있는 길이 없었던 경우
      /*  for(int g=0;g<35;g++){
        DFA[sln][g]=86;
        }*/
        sln+=1;
    }
    else{//해당 상태에서 symbol로 갈 수 있는 길이 있는경우
        
        for(int i=0;i<tempSV.size();i++){//모든 갈 수 있는 트랜지션 심볼에 대해..
            temint=0;
            existStateNum=0;
           
         
            temv=eMoveResult(dfaNextState_needEMR(statelist[sln],tempSV[i]));//현재 확정되어있는 dfa state에서 가능한 트랜지션 심볼 하나에 대해 다음 dfa state 후보가 나옴 얘가 statelist에 없었으면 추가하면 됨.
            if(ssno==5){
                
                cout<<tempSV[i];
                for(int e=0;e<temv.size();e++){
                    cout<<temv[e]<<" ";
                }
            }
            sort(temv.begin(),temv.end());
           ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
            for(int j=0;j<statelist.size();j++){//방금 나온 temv 라는 dfa state 후보가 원래 있던 건지 없던건지. 없었으면 추가
                if(vecComp(statelist[j],temv)==false){
                    temint++;//for문 밖에 나가서 temint가 0이 아니면 겹...
                }
                else{//방금 나온 temv라는 dfa state 후보인 int형 벡터가 이미 statelist에 있어 똑같은게
                    existStateNum=j;//그래. statelist에 이미 있었는데 그게 몇번째 인덱스에 있었는지 저장.
                    break;
                }
            }
            /////////////////////////////////////////////////temv가 statelist에 있는지 없는지 ( 즉, 추가해도 되는지) 확인한겨!!////////////////////////////////////////////////
            
            if(temint==statelist.size()){ //모든 statelist의 원소들과 겹치지 않았던거..
            
                statelist.push_back(temv);//statelist에 추가해도 된다!
               
                for(int k=0;k<35;k++){
                if(tempSV[i]==smap[k]){
                     DFA[sln][k]= temint;
                }
                }
               
                
            }
            else{ //방금 나온 dfa state후보가 이미 있었던거 -> 추가필요 트랝션만
               for(int k=0;k<35;k++){
                              if(tempSV[i]==smap[k]){
                                    DFA[sln][k]=existStateNum;
                              }
                              }
               
                }
            
            
        }sln+=1;
  }
        
        
}  //while문 빠져나오면 dfa 구성 끝난거임.
 
    cout<< statelist.size()<<endl;
    
    for(int r=0;r<85;r++){
        cout<<"{ ";
        for(int l=0;l<35;l++){
            cout<<DFA[r][l];
            if(l!=34){
                cout<<" , ";
            }
        }cout<<" },"<<endl;
    }
    
    
    
    for(int s=0;s<statelist.size();s++){
        cout<<"vector<int> d"<<s<<"={ ";
        for(int t=0;t<statelist[s].size();t++){
            cout<<statelist[s][t];
            if(t!=statelist[s].size()-1){
                cout<<" , ";
            }
        }cout<<" };"<<endl;
       
    }
  

      /* Terminal 20가지 vtype, num, float, literal, id, if, else, while, for, return, addsub, multdiv,assign, comp, semi, comma, lparen, rparen, lbrace, rbrace  Non-terminal 15가지 CODE, VDECL, ASSIGN, FDECL, ARG, MOREARGS, BLOCK, STMT, ELSE,RHS, EXPR, TERM, FACTOR, COND, RETURN */
    
    
    
    

    
    
    
}
